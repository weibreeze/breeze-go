/*
 * Generated by breeze-generator (https://github.com/weibreeze/breeze-generator)
 * Schema: testmsg.breeze
 * Date: 2019/6/6
 */
package breeze

import (
	"errors"
	"strconv"
)

const (
	MyEnumE1 MyEnum = 1
	MyEnumE2 MyEnum = 2
	MyEnumE3 MyEnum = 3
)

type MyEnum int

func (m MyEnum) WriteTo(buf *Buffer) error {
	return WriteMessage(buf, m.GetName(), func(funcBuf *Buffer) {
		WriteMessageField(funcBuf, 1, int(m))
	})
}

func (m MyEnum) ReadFrom(buf *Buffer) error {
	return errors.New("can not read enum by Message.ReadFrom, Enum.ReadEnum is expected. name:" + m.GetName())
}

func (m MyEnum) ReadEnum(buf *Buffer, asAddr bool) (Enum, error) {
	var number int
	e := ReadMessageByField(buf, func(funcBuf *Buffer, index int) (err error) {
		switch index {
		case 1:
			err = ReadInt(buf, &number)
		default: //skip unknown field
			_, err = ReadValue(funcBuf, nil)
		}
		return err
	})
	if e == nil {
		var result MyEnum
		switch number {
		case 1:
			result = MyEnumE1
		case 2:
			result = MyEnumE2
		case 3:
			result = MyEnumE3
		default:
			return nil, errors.New("unknown enum number " + strconv.Itoa(number))
		}
		if asAddr {
			return &result, nil
		}
		return result, nil
	}
	return nil, e
}

func (m MyEnum) GetName() string {
	return myEnumBreezeSchema.Name
}

func (m MyEnum) GetAlias() string {
	return myEnumBreezeSchema.Alias
}

func (m MyEnum) GetSchema() *Schema {
	return myEnumBreezeSchema
}

type TestMsg struct {
	MyInt     int32
	MyString  string
	MyMap     map[string]*TestSubMsg
	MyArray   []*TestSubMsg
	SubMsg    *TestSubMsg
	MyEnum    *MyEnum
	EnumArray []*MyEnum
}

func (t *TestMsg) WriteTo(buf *Buffer) error {
	return WriteMessage(buf, t.GetName(), func(funcBuf *Buffer) {
		if t.MyInt != 0 {
			WriteMessageField(funcBuf, 1, t.MyInt)
		}
		if t.MyString != "" {
			WriteMessageField(funcBuf, 2, t.MyString)
		}
		if len(t.MyMap) > 0 {
			WriteMessageField(funcBuf, 3, t.MyMap)
		}
		if len(t.MyArray) > 0 {
			WriteMessageField(funcBuf, 4, t.MyArray)
		}
		if t.SubMsg != nil {
			WriteMessageField(funcBuf, 5, t.SubMsg)
		}
		if t.MyEnum != nil {
			WriteMessageField(funcBuf, 6, t.MyEnum)
		}
		if len(t.EnumArray) > 0 {
			WriteMessageField(funcBuf, 7, t.EnumArray)
		}
	})
}

func (t *TestMsg) ReadFrom(buf *Buffer) error {
	return ReadMessageByField(buf, func(funcBuf *Buffer, index int) (err error) {
		switch index {
		case 1:
			_, err = ReadValue(funcBuf, &t.MyInt)
		case 2:
			_, err = ReadValue(funcBuf, &t.MyString)
		case 3:
			t.MyMap = make(map[string]*TestSubMsg, 16)
			_, err = ReadValue(funcBuf, &t.MyMap)
		case 4:
			t.MyArray = make([]*TestSubMsg, 0, 16)
			_, err = ReadValue(funcBuf, &t.MyArray)
		case 5:
			t.SubMsg = &TestSubMsg{}
			_, err = ReadValue(funcBuf, t.SubMsg)
		case 6:
			var value MyEnum
			_, err = ReadValue(funcBuf, &value)
			t.MyEnum = &value
		case 7:
			t.EnumArray = make([]*MyEnum, 0, 16)
			_, err = ReadValue(funcBuf, &t.EnumArray)
		default: //skip unknown field
			_, err = ReadValue(funcBuf, nil)
		}
		return err
	})
}

func (t *TestMsg) GetName() string {
	return testMsgBreezeSchema.Name
}

func (t *TestMsg) GetAlias() string {
	return testMsgBreezeSchema.Alias
}

func (t *TestMsg) GetSchema() *Schema {
	return testMsgBreezeSchema
}

type TestSubMsg struct {
	MyString  string
	MyInt     int32
	MyInt64   int64
	MyFloat32 float32
	MyFloat64 float64
	MyByte    byte
	MyBytes   []byte
	MyMap1    map[string][]byte
	MyMap2    map[int32][]int32
	MyArray   []int32
	MyBool    bool
}

func (t *TestSubMsg) WriteTo(buf *Buffer) error {
	return WriteMessage(buf, t.GetName(), func(funcBuf *Buffer) {
		if t.MyString != "" {
			WriteMessageField(funcBuf, 1, t.MyString)
		}
		if t.MyInt != 0 {
			WriteMessageField(funcBuf, 2, t.MyInt)
		}
		if t.MyInt64 != 0 {
			WriteMessageField(funcBuf, 3, t.MyInt64)
		}
		if t.MyFloat32 != 0 {
			WriteMessageField(funcBuf, 4, t.MyFloat32)
		}
		if t.MyFloat64 != 0 {
			WriteMessageField(funcBuf, 5, t.MyFloat64)
		}
		if t.MyByte != 0 {
			WriteMessageField(funcBuf, 6, t.MyByte)
		}
		if len(t.MyBytes) > 0 {
			WriteMessageField(funcBuf, 7, t.MyBytes)
		}
		if len(t.MyMap1) > 0 {
			WriteMessageField(funcBuf, 8, t.MyMap1)
		}
		if len(t.MyMap2) > 0 {
			WriteMessageField(funcBuf, 9, t.MyMap2)
		}
		if len(t.MyArray) > 0 {
			WriteMessageField(funcBuf, 10, t.MyArray)
		}
		if t.MyBool {
			WriteMessageField(funcBuf, 11, t.MyBool)
		}
	})
}

func (t *TestSubMsg) ReadFrom(buf *Buffer) error {
	return ReadMessageByField(buf, func(funcBuf *Buffer, index int) (err error) {
		switch index {
		case 1:
			_, err = ReadValue(funcBuf, &t.MyString)
		case 2:
			_, err = ReadValue(funcBuf, &t.MyInt)
		case 3:
			_, err = ReadValue(funcBuf, &t.MyInt64)
		case 4:
			_, err = ReadValue(funcBuf, &t.MyFloat32)
		case 5:
			_, err = ReadValue(funcBuf, &t.MyFloat64)
		case 6:
			_, err = ReadValue(funcBuf, &t.MyByte)
		case 7:
			_, err = ReadValue(funcBuf, &t.MyBytes)
		case 8:
			t.MyMap1 = make(map[string][]byte, 16)
			_, err = ReadValue(funcBuf, &t.MyMap1)
		case 9:
			t.MyMap2 = make(map[int32][]int32, 16)
			_, err = ReadValue(funcBuf, &t.MyMap2)
		case 10:
			t.MyArray = make([]int32, 0, 16)
			_, err = ReadValue(funcBuf, &t.MyArray)
		case 11:
			_, err = ReadValue(funcBuf, &t.MyBool)
		default: //skip unknown field
			_, err = ReadValue(funcBuf, nil)
		}
		return err
	})
}

func (t *TestSubMsg) GetName() string {
	return testSubMsgBreezeSchema.Name
}

func (t *TestSubMsg) GetAlias() string {
	return testSubMsgBreezeSchema.Alias
}

func (t *TestSubMsg) GetSchema() *Schema {
	return testSubMsgBreezeSchema
}

var myEnumBreezeSchema *Schema
var testMsgBreezeSchema *Schema
var testSubMsgBreezeSchema *Schema

func init() {
	myEnumBreezeSchema = &Schema{Name: "motan.MyEnum"}
	myEnumBreezeSchema.PutFields(&Field{Index: 1, Name: "enumNumber", Type: "int32"})

	testMsgBreezeSchema = &Schema{Name: "motan.TestMsg"}
	testMsgBreezeSchema.PutFields(&Field{Index: 1, Name: "myInt", Type: "int32"})
	testMsgBreezeSchema.PutFields(&Field{Index: 2, Name: "myString", Type: "string"})
	testMsgBreezeSchema.PutFields(&Field{Index: 3, Name: "myMap", Type: "map<string, TestSubMsg>"})
	testMsgBreezeSchema.PutFields(&Field{Index: 4, Name: "myArray", Type: "array<TestSubMsg>"})
	testMsgBreezeSchema.PutFields(&Field{Index: 5, Name: "subMsg", Type: "TestSubMsg"})
	testMsgBreezeSchema.PutFields(&Field{Index: 6, Name: "myEnum", Type: "MyEnum"})
	testMsgBreezeSchema.PutFields(&Field{Index: 7, Name: "enumArray", Type: "array<MyEnum>"})

	testSubMsgBreezeSchema = &Schema{Name: "motan.TestSubMsg"}
	testSubMsgBreezeSchema.PutFields(&Field{Index: 1, Name: "myString", Type: "string"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 2, Name: "myInt", Type: "int32"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 3, Name: "myInt64", Type: "int64"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 4, Name: "myFloat32", Type: "float32"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 5, Name: "myFloat64", Type: "float64"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 6, Name: "myByte", Type: "byte"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 7, Name: "myBytes", Type: "bytes"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 8, Name: "myMap1", Type: "map<string, bytes>"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 9, Name: "myMap2", Type: "map<int32, array<int32>>"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 10, Name: "myArray", Type: "array<int32>"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 11, Name: "myBool", Type: "bool"})
}

func getTestMsg() *TestMsg {
	tsm := getTestSubMsg()
	t := &TestMsg{MyInt: 123, MyString: "jiernoce"}
	t.MyMap = make(map[string]*TestSubMsg)
	t.MyMap["m1"] = tsm
	t.MyArray = make([]*TestSubMsg, 0, 12)
	t.MyArray = append(t.MyArray, tsm)
	myEnum := MyEnumE3
	t.MyEnum = &myEnum
	myEnum2 := MyEnumE2
	enumArray := []*MyEnum{&myEnum, &myEnum2}
	t.EnumArray = enumArray
	return t
}

func getTestSubMsg() *TestSubMsg {
	tsm := &TestSubMsg{MyString: "uoiwer", MyInt: 2134, MyInt64: 234, MyFloat32: 23.434, MyFloat64: 8923.234234, MyByte: 5, MyBytes: []byte("ipower"), MyBool: true}
	im1 := make(map[string][]byte, 16)
	im1["jdie"] = []byte("ierjkkkd")
	im1["jddfwwie"] = []byte("ieere9943rjkkkd")
	tsm.MyMap1 = im1
	il := make([]int32, 0, 12)
	il = append(il, 34)
	il = append(il, 56)
	im2 := make(map[int32][]int32, 16)
	im2[12] = il
	im2[3] = []int32{34, 45, 657}
	im2[6] = []int32{23, 66}
	tsm.MyMap2 = im2
	tsm.MyArray = []int32{234, 6456, 234, 6859}
	return tsm
}
