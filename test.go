/*
 * Generated by breeze-generator (https://github.com/weibreeze/breeze-generator)
 * Schema: testmsg.breeze
 * Date: 2019/6/6
 */
package breeze

import (
	"errors"
	"strconv"
)

const (
	MyEnumE1 MyEnum = 1
	MyEnumE2 MyEnum = 2
	MyEnumE3 MyEnum = 3
)

type MyEnum int

func (m MyEnum) WriteTo(buf *Buffer) error {
	return WriteMessageWithoutType(buf, func(buf *Buffer) {
		WriteInt32Field(buf, 1, int32(m))
	})
}

func (m MyEnum) ReadFrom(buf *Buffer) error {
	return errors.New("can not read enum by Message.ReadFrom, Enum.ReadEnum is expected. name:" + m.GetName())
}

func (m MyEnum) ReadEnum(buf *Buffer, asAddr bool) (Enum, error) {
	var number int32
	e := ReadMessageField(buf, func(buf *Buffer, index int) (err error) {
		switch index {
		case 1:
			err = ReadInt32(buf, &number)
		default: //skip unknown field
			_, err = ReadValue(buf, nil)
		}
		return err
	})
	if e == nil {
		var result MyEnum
		switch number {
		case 1:
			result = MyEnumE1
		case 2:
			result = MyEnumE2
		case 3:
			result = MyEnumE3
		default:
			return nil, errors.New("unknown enum number " + strconv.Itoa(int(number)))
		}
		if asAddr {
			return &result, nil
		}
		return result, nil
	}
	return nil, e
}

func (m MyEnum) GetName() string {
	return myEnumBreezeSchema.Name
}

func (m MyEnum) GetAlias() string {
	return myEnumBreezeSchema.Alias
}

func (m MyEnum) GetSchema() *Schema {
	return myEnumBreezeSchema
}

type TestMsg struct {
	MyInt     int32
	MyString  string
	MyMap     map[string]*TestSubMsg
	MyArray   []*TestSubMsg
	SubMsg    *TestSubMsg
	MyEnum    *MyEnum
	EnumArray []*MyEnum
}

func (t *TestMsg) WriteTo(buf *Buffer) error {
	return WriteMessageWithoutType(buf, func(buf *Buffer) {
		WriteInt32Field(buf, 1, t.MyInt)
		WriteStringField(buf, 2, t.MyString)
		if len(t.MyMap) > 0 {
			WriteMapField(buf, 3, len(t.MyMap), func(buf *Buffer) {
				first := true
				for k1, v1 := range t.MyMap {
					if first {
						WriteStringType(buf)
						WriteMessageType(buf, v1.GetName())
						first = false
					}
					WriteString(buf, k1, false)
					v1.WriteTo(buf)
				}
			})
		}
		if len(t.MyArray) > 0 {
			WriteArrayField(buf, 4, len(t.MyArray), func(buf *Buffer) {
				first := true
				for _, v1 := range t.MyArray {
					if first {
						WriteMessageType(buf, v1.GetName())
						first = false
					}
					v1.WriteTo(buf)
				}
			})
		}
		if t.SubMsg != nil {
			WriteMessageField(buf, 5, t.SubMsg)
		}
		if t.MyEnum != nil {
			WriteMessageField(buf, 6, t.MyEnum)
		}
		if len(t.EnumArray) > 0 {
			WriteArrayField(buf, 7, len(t.EnumArray), func(buf *Buffer) {
				first := true
				for _, v1 := range t.EnumArray {
					if first {
						WriteMessageType(buf, v1.GetName())
						first = false
					}
					v1.WriteTo(buf)
				}
			})
		}
	})
}

func (t *TestMsg) ReadFrom(buf *Buffer) error {
	return ReadMessageField(buf, func(buf *Buffer, index int) (err error) {
		switch index {
		case 1:
			err = ReadInt32(buf, &t.MyInt)
		case 2:
			err = ReadString(buf, &t.MyString)
		case 3:
			size, err := ReadPackedSize(buf, true)
			if err != nil {
				return err
			}
			t.MyMap = make(map[string]*TestSubMsg, size)
			err = ReadPacked(buf, size, true, func(buf *Buffer) error {
				k1, err := ReadStringWithoutType(buf)
				if err != nil {
					return err
				}
				v1 := &TestSubMsg{}
				err = v1.ReadFrom(buf)
				if err == nil {
					t.MyMap[k1] = v1
				}
				return err
			})
			return err
		case 4:
			size, err := ReadPackedSize(buf, true)
			if err != nil {
				return err
			}
			t.MyArray = make([]*TestSubMsg, 0, size)
			err = ReadPacked(buf, size, false, func(buf *Buffer) error {
				v1 := &TestSubMsg{}
				err = v1.ReadFrom(buf)
				if err == nil {
					t.MyArray = append(t.MyArray, v1)
				}
				return err
			})
			return err
		case 5:
			t.SubMsg = &TestSubMsg{}
			return ReadByMessage(buf, t.SubMsg)
		case 6:
			var value MyEnum
			result, err := ReadByEnum(buf, value, true)
			if err == nil {
				t.MyEnum = result.(*MyEnum)
			}
		case 7:
			size, err := ReadPackedSize(buf, true)
			if err != nil {
				return err
			}
			t.EnumArray = make([]*MyEnum, 0, size)
			err = ReadPacked(buf, size, false, func(buf *Buffer) error {
				var enum MyEnum
				result, err := enum.ReadEnum(buf, true)
				if err == nil {
					t.EnumArray = append(t.EnumArray, result.(*MyEnum))
				}
				return err
			})
			return err
		default: //skip unknown field
			_, err = ReadValue(buf, nil)
		}
		return err
	})
}

func (t *TestMsg) GetName() string {
	return testMsgBreezeSchema.Name
}

func (t *TestMsg) GetAlias() string {
	return testMsgBreezeSchema.Alias
}

func (t *TestMsg) GetSchema() *Schema {
	return testMsgBreezeSchema
}

type TestSubMsg struct {
	MyString  string
	MyInt     int32
	MyInt64   int64
	MyFloat32 float32
	MyFloat64 float64
	MyByte    byte
	MyBytes   []byte
	MyMap1    map[string][]byte
	MyMap2    map[int32][]int32
	MyArray   []int32
	MyBool    bool
}

func (t *TestSubMsg) WriteTo(buf *Buffer) error {
	return WriteMessageWithoutType(buf, func(buf *Buffer) {
		WriteStringField(buf, 1, t.MyString)
		WriteInt32Field(buf, 2, t.MyInt)
		WriteInt64Field(buf, 3, t.MyInt64)
		WriteFloat32Field(buf, 4, t.MyFloat32)
		WriteFloat64Field(buf, 5, t.MyFloat64)
		WriteByteField(buf, 6, t.MyByte)
		WriteBytesField(buf, 7, t.MyBytes)
		if len(t.MyMap1) > 0 {
			WriteMapField(buf, 8, len(t.MyMap1), func(buf *Buffer) {
				WriteStringType(buf)
				WriteBytesType(buf)
				for k1, v1 := range t.MyMap1 {
					WriteString(buf, k1, false)
					WriteBytes(buf, v1, false)
				}
			})
		}
		if len(t.MyMap2) > 0 {
			WriteMapField(buf, 9, len(t.MyMap2), func(buf *Buffer) {
				WriteInt32Type(buf)
				WritePackedArrayType(buf)
				for k1, v1 := range t.MyMap2 {
					WriteInt32(buf, k1, false)
					WritePackedArray(buf, false, len(v1), func(buf *Buffer) {
						WriteInt32ArrayElems(buf, v1)
					})
				}
			})
		}
		if len(t.MyArray) > 0 {
			WriteArrayField(buf, 10, len(t.MyArray), func(buf *Buffer) {
				WriteInt32ArrayElems(buf, t.MyArray)
			})
		}
		WriteBoolField(buf, 11, t.MyBool)
	})
}

func (t *TestSubMsg) ReadFrom(buf *Buffer) error {
	return ReadMessageField(buf, func(buf *Buffer, index int) (err error) {
		switch index {
		case 1:
			err = ReadString(buf, &t.MyString)
		case 2:
			err = ReadInt32(buf, &t.MyInt)
		case 3:
			err = ReadInt64(buf, &t.MyInt64)
		case 4:
			err = ReadFloat32(buf, &t.MyFloat32)
		case 5:
			err = ReadFloat64(buf, &t.MyFloat64)
		case 6:
			err = ReadByte(buf, &t.MyByte)
		case 7:
			err = ReadBytes(buf, &t.MyBytes)
		case 8:
			size, err := ReadPackedSize(buf, true)
			if err != nil {
				return err
			}
			t.MyMap1 = make(map[string][]byte, size)
			err = ReadPacked(buf, size, true, func(buf *Buffer) error {
				k1, err := ReadStringWithoutType(buf)
				if err != nil {
					return err
				}
				v1, err := ReadBytesWithoutType(buf)
				if err == nil {
					t.MyMap1[k1] = v1
				}
				return err
			})
			return err
		case 9:
			size, err := ReadPackedSize(buf, true)
			if err != nil {
				return err
			}
			t.MyMap2 = make(map[int32][]int32, size)
			err = ReadPacked(buf, size, true, func(buf *Buffer) error {
				k1, err := ReadInt32WithoutType(buf)
				if err != nil {
					return err
				}
				v1, err := ReadInt32Array(buf, false)
				if err == nil {
					t.MyMap2[k1] = v1
				}
				return err
			})
			return err
		case 10:
			t.MyArray, err = ReadInt32Array(buf, true)
		case 11:
			err = ReadBool(buf, &t.MyBool)
		default: //skip unknown field
			_, err = ReadValue(buf, nil)
		}
		return err
	})
}

func (t *TestSubMsg) GetName() string {
	return testSubMsgBreezeSchema.Name
}

func (t *TestSubMsg) GetAlias() string {
	return testSubMsgBreezeSchema.Alias
}

func (t *TestSubMsg) GetSchema() *Schema {
	return testSubMsgBreezeSchema
}

var myEnumBreezeSchema *Schema
var testMsgBreezeSchema *Schema
var testSubMsgBreezeSchema *Schema

func init() {
	myEnumBreezeSchema = &Schema{Name: "motan.MyEnum"}
	myEnumBreezeSchema.PutFields(&Field{Index: 1, Name: "enumNumber", Type: "int32"})

	testMsgBreezeSchema = &Schema{Name: "motan.TestMsg"}
	testMsgBreezeSchema.PutFields(&Field{Index: 1, Name: "myInt", Type: "int32"})
	testMsgBreezeSchema.PutFields(&Field{Index: 2, Name: "myString", Type: "string"})
	testMsgBreezeSchema.PutFields(&Field{Index: 3, Name: "myMap", Type: "map<string, TestSubMsg>"})
	testMsgBreezeSchema.PutFields(&Field{Index: 4, Name: "myArray", Type: "array<TestSubMsg>"})
	testMsgBreezeSchema.PutFields(&Field{Index: 5, Name: "subMsg", Type: "TestSubMsg"})
	testMsgBreezeSchema.PutFields(&Field{Index: 6, Name: "myEnum", Type: "MyEnum"})
	testMsgBreezeSchema.PutFields(&Field{Index: 7, Name: "enumArray", Type: "array<MyEnum>"})

	testSubMsgBreezeSchema = &Schema{Name: "motan.TestSubMsg"}
	testSubMsgBreezeSchema.PutFields(&Field{Index: 1, Name: "myString", Type: "string"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 2, Name: "myInt", Type: "int32"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 3, Name: "myInt64", Type: "int64"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 4, Name: "myFloat32", Type: "float32"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 5, Name: "myFloat64", Type: "float64"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 6, Name: "myByte", Type: "byte"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 7, Name: "myBytes", Type: "bytes"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 8, Name: "myMap1", Type: "map<string, bytes>"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 9, Name: "myMap2", Type: "map<int32, array<int32>>"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 10, Name: "myArray", Type: "array<int32>"})
	testSubMsgBreezeSchema.PutFields(&Field{Index: 11, Name: "myBool", Type: "bool"})
}

func getTestMsg() *TestMsg {
	tsm := getTestSubMsg()
	t := &TestMsg{MyInt: 12, MyString: "jiernoce"}
	t.MyMap = make(map[string]*TestSubMsg)
	t.MyMap["m1"] = tsm
	t.MyArray = make([]*TestSubMsg, 0, 12)
	t.MyArray = append(t.MyArray, tsm)
	myEnum := MyEnumE3
	t.MyEnum = &myEnum
	myEnum2 := MyEnumE2
	enumArray := []*MyEnum{&myEnum, &myEnum2}
	t.EnumArray = enumArray
	return t
}

func getTestSubMsg() *TestSubMsg {
	return getTestSubMsgByInt(2134)
}

func getTestSubMsgByInt(i int32) *TestSubMsg {
	tsm := &TestSubMsg{MyString: "uoiwer", MyInt: i, MyInt64: 234, MyFloat32: 23.434, MyFloat64: 8923.234234, MyByte: 5, MyBytes: []byte("ipower"), MyBool: true}
	im1 := make(map[string][]byte, 16)
	im1["jdie"] = []byte("ierjkkkd")
	im1["jddfwwie"] = []byte("ieere9943rjkkkd")
	tsm.MyMap1 = im1
	il := make([]int32, 0, 12)
	il = append(il, 34)
	il = append(il, -15)
	im2 := make(map[int32][]int32, 16)
	im2[12] = il
	im2[3] = []int32{34, 45, 657}
	im2[6] = []int32{23, 66}
	tsm.MyMap2 = im2
	tsm.MyArray = []int32{234, 6456, 234, 6859}
	return tsm
}

func GetBenchData(size int) *TestMsg {
	testmsg := getTestMsg()
	for i := 0; i < size; i++ {
		testmsg.MyMap["k"+strconv.Itoa(i)] = getTestSubMsgByInt(int32(i))
	}
	return testmsg
}
